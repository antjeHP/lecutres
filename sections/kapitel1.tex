\section{Zahlendarstellung am Computer}
\subsection{Zahlensystem}
Die Darstellung von Zahlen basiert auf sogenannten \emph{Zahlensystemen}.
Diese Zahlensysteme unterscheiden sich in der Wahl des zugrundeliegendes Alphabets.
Unsere Zahl entspricht dann einem Wort, bestehend aus Elementen des Alphabets.\\


\begin{definition}[Alphabet]
Es sei $\N = \{ 1,2,3\ldots \}$ und $b \in  \N$. \\
Wir bezeichnen mit $\sum_{b}$ das Alphabet des \emph{b-adischen Zahlensystems}
\end{definition}

\begin{example}
Verschiedene Zahlensysteme
\begin{enumerate}
	\item Dezimalsystem: $\sum_{10}= \{0,1,\ldots,9\}$ \\ wie $(384)_10$
	\item Dual bzw. Binärsystem $\sum_2 = \{0,1\}$ \\ wie $(42)_10 = (101010)_2$
	\item \ldots
\end{enumerate}
\end{example}
Um die Zahlendarstellung sinnvoll zu nutzen Ergibt sich folgendes:
\begin{theorem}[]
Seien $b,n \in  \N, b>1 $. \\
Dann ist jede ganze, nicht-negative Zahl $z$ mit $0\le z \le b^{n}-1$ \emph{eindeutig} als Wort der Länge $n$ über $\sum_b$ darstellbar durch:
\[
z=\sum_{i=0}^{n-1}z_ib^{i}
\]
mit $z_i \in \sum_b$ für alle $i=0,1,\ldots,n-1$. \\
Wir schreiben vereinfachend: 
\[
z=(z_{n-1},\ldots, z_0)_b
\]
\end{theorem}
\begin{proof}

\begin{itemize}
\item Induktion \medskip
\begin{itemize}[label=$\lozenge$, itemsep=2ex]
\item \emph{Induktionsanfang}: \underline{$z<b$} hat die eindeutige Darstellung $z_0=z$ und $z_i=0$ sonst.



\item \emph{Induktionsschritt}: \underline{$z-1 \to z\ge b$} \\   

Betrachte
\[
z= \left\lfloor{\frac{z}{b}}\right\rfloor \cdot b + (z \mod b)
\]
Da $\hat{z}<z$ besitzt die eindeutige Darstellung
\[
\hat{z}= (\hat{z_{n-1}},\ldots, \hat{z_0})_b
\]
Bemerke $\hat{z_{n-1}}=0$, da 
\[
\left( \hat{z_{n-1}}b^{n-1} \right)b \le z \le b^{n}-1
\]
Also ist $z_b$ eine n-stellige Darstellung von z in b-adischen Zahlensystem

\end{itemize}

\item Eindeutigkeit wird durch Widerspruch gezeigt. \\
\emph{Angenommen:} Es gibt zwei verschiedene Darstellungen
\[
z=\left( z_{n-1}^{(2)},\ldots, z_0^{(2)} \right)_b = \left(z_{n-1}^{(1)},\ldots,z_0^{(1)} \right)_b
\]
Sei $m \in  \N$ der größte Index mit $z_m^{(1)} \neq z_m^{(2)}$, \\
Ohne Beschränkung der Allgemeinheit kann gesagt werden $z_m^{(1)>z_m^{(2)}}$. \\
Dann müssten die Stellen $0,1,\ldots,m-1$ den niedrigeren Wert von $z_m^{(2)}$ kompensieren. Die größte mit diesen Stellen darstellbare Zahl ist aber:
\[
\sum_{i=0}^{m-1}(b-1)b^{i}= (b-1)\sum_{i=0}^{m-1}b^{i}= b^{m}-1 \text{.}
\]
Da $b^{m}$ der kleinstmögliche Wert der fehlende Stelle m ist, kann diese aber nicht kompensiert werden. Dies ist ein Widerspruch.
\end{itemize}
\end{proof}%
Durch den Beweis ergibt sich sofort ein Algorithmus zur Umwandlung einer Zahl in ein anderes Zahlensystem:
\begin{example}
Umwandlung von $(1364)_{10}$ in das Oktalsystem.
\begin{itemize}
	\item $1364 = 170 \cdot 8 +4$
	\item $170 = 21 \cdot 8 +2$
	\item \ldots
	\item $0 \cdot 8 + 2$
\end{itemize}
$\implies (2524)_8$
\end{example}

\begin{algorithm}[H]
 \caption{Bestimmung der b-adischen Darstellung}
 \KwData{Dezimalzahl $z \in \N_0$, Basis $b \in \N$}
 \KwResult{b-adische Darstellung $(z_{n-1},\ldots, z_0)_b $}
 Initialisiere $i=0$ \\
 \While{$z>0$}{
  $z_i = z \mod b $\\
  $z= \left\lfloor \frac{z}{b} \right\rfloor$ \\
  $i=i+1$
 }
 \end{algorithm}

\paragraph{Beobachtung}
Wir sehen, dass das Honor-Schmea nur eine Schleife, Additionen und Multiplikationen benötigt. 
Diese Operationen können wir am Computer durchführen. 
Im Gegensatz dazu steht die Potenz $b^{i}$ in modernen Programmiersprachen zwar zur Verfügung, wird aber im Hintergrund oft auf Multiplikationen zurückgeführt.
Man überprüft leicht, dass das Honor-Schema weniger Multiplikationen benötigt und somit schnellt ist.
\subsection{Vorzeichen-Betrag-Darstellung}
Um auch Zahlen mit Vorzeichen am Computer darstellen zu können, betrachten wir im Folgenden die Vorzeichen-Betrag-Darstellung für Binärzahlen.
Das Binäralphabet besteht nur aus $0$ und $1$, welche wir auch als \emph{Bits} bezeichnen.
Bei einer Wortlänge von n Bits wir das erste Bit als Vorzeichen verwendet, die restlichen $n-1$-Bits für den Betrag der Zahl. Da die 0 die Darstellung $+0$ und $-O$ besitzt, können wir insgesamt $2^{n}-1$ Zahlen darstellen.

\begin{example}
Für $n=3$\\

\begin{table}[htpb]
	\centering
	\begin{tabular}{c c}
		Bitmuster & Dezimaldarstellung \\
		$000$ & $+0$ \\
		$001$ & $+1$ \\
		$\ldots$ & $\ldots$ \\
		$100$ & $-0$ \\
		$\ldots$ & $\ldots$ \\
		$111$ & $-3$
	\end{tabular}
\end{table}
\end{example}

\paragraph{Aber:} Diese Darstellung am Computer ist unpraktisch, da die vier Grundrechenarten auf Hardwareebene typischerweise mit Hilfe von Addition und Zusatz-Logik umgesetzt werden.
\paragraph{Lösung:} Komplementdarstellung

\subsection{Komplementdarstellung}

\begin{definition}[(b-1)-Komplement]
Sei $z=(z_{n-1}\ldots z_1 z_0)_b$ eine n-stellige b-adische Zahl. Das \emph{(b-1)-Komplement} $K_{b-1}(z)$ ist definiert als:
\[
K_{b-1} = (b-1-z_{n-q},\ldots, b-1-z_0)_b
\]
\end{definition}
Geben wir hierzu direkt ein paar Beispiele an
\begin{example} Komplemente \\
\begin{itemize}
	\item $K_9((325)_{10})= (674)_{10}$  (9er-Komplement im 10-er System)
	\item $K_1((10110)_2)=(01001)_2$ (1er-Komplement im 2er System)
\end{itemize}
\end{example}
\begin{definition}[b-Komplement]
Das b-Komplement einer b-adischen Zahl $z\neq 0$ ist definiert als \[
K_b(z)=K_{b-1}(z) +(1)_b
\]
\end{definition}
\begin{example}
\begin{itemize}
	\item $K_{10}((325)_{10}) = (674)_{10} + (1)_{10} = (675)_{10}$
\end{itemize}
\end{example}
\begin{lemma}[]
Für jede n-stellige b-adische Zahl $z$ gilt:
\begin{itemize}
	
	\item i) $z+K_{b-1}(z)=(b-1,\ldots,b-1)_b = b^{n}-1$
	\item ii) $K_{b-1}\left( K_{b-1}(z) \right)=z$
\end{itemize}
Ist außerdem $z\neq 0$ so gilt:
\begin{itemize}
	
	\item iii) $z+K_b(z)=b^{n}$
	\item iv) $K_b(K_b(z))=z$
\end{itemize}
\end{lemma}
\begin{proof}
\begin{itemize}Hilfssatz \\
	\item (i) Durch nachrechnen:
		\begin{align*}
		z+K_{b-1}(z)
		&=(z_{n-1} \ldots z_0)_b +(b-1-z_{n-1}, \ldots, b-1-z_0)_b \\
		&=\sum_{i=0}^{n-1}z_ib^{i}+ \sum_{i=0}^{n-1}(b-1-z_i)b^{i}\\
		&= \sum_{i=0}^{n-1}(b-1)b^{i} = (b-1, \ldots, b-1)_b \\
		&= (b-1)\sum_{i=0}^{n-1}b^{i} \\
		&=(b-1)\left( \frac{b^{n}-1}{b-1} \right) \\
		&= b^{n}-1
		\end{align*}
	\item (ii) per Definition
	\item (iii) Nachrechnen:
	\begin{align*}
		z+K_b(z) = z+K_{b-1} + 1 = b^{n}-1+1=b^{n}
	\end{align*}
	\item Definiere $\hat{z} = K_b\left( z \right)= K_{b-1}(z) + (1)_b > 0$ und rechne
		\[
		z+K_b(z)=b^{n}=\hat{z} +K_b{\hat{z}}+ K_b\left( K_b(z) \right) \implies \text{Behauptung.}
		\]
\end{itemize}



\end{proof}

\begin{remark} Modifikation 
\begin{itemize}
	\item Die 3. Aussage gilt auch für $z=0$, falls man dann bei der Addition von 1 die Anzahl der Stellen erweitert.
	\item die 4. Aussage gilt für $z=0$, falls überall im Beweis modulo $b^{n}$ gerechnet wird.
\end{itemize}
\end{remark}
Außerdem impliziert die 3. Aussage des Lemmas, dass 
\begin{equation}\label{eqn:komplement}
	K_b(z)=b^{n}-z \text{.}
\end{equation}
Dies können wir geschickt zum Darstellen der $b^{n}$ verschiedenen ganzen Zahlen $z$ mit 
\[
-\left\lfloor \frac{b^{n}}{2}\right\rfloor \le z \le \left\lceil \frac{b^{n}}{2}\right\rceil -1
\]
nutzen. Diesen Bereich nennt man darstellbaren Bereich.
\begin{definition}[b-Komplement-Darstellung]
	Die b-Komplement-Darstellung $(z)_{K_b} = (z_{n-1} \ldots z_0)_b$ einer Zahl $z \in  \Z$ im darstellbaren Bereich ist definiert als:
	\[
		(z)_{K_b}= \begin{cases}
			(z)_b & \text{falls } z \ge 0 \\
			\left( K_b(|z|) \right)_b & \text{falls } z<0
		\end{cases}
	\]
\end{definition}

\begin{example} Der darstellbare Bereich.
\begin{itemize}
	\item Sei $b = 10$, $n=2$. \\ 
Dann impliziert \eqref{eqn:komplement}, dass
\[
K_{10}(50)= 10^2-50=50
\]
\[
K_{10}(49)= 100 -49=51 \text{.}
\]
Der darstellbare Bereich ist nun 
\[
-50 \le z \le 49
\]
und hat konkrete Darstellungen:

\begin{center}
\begin{tabular}{ c c }
 Darstellung & Zahl   \\
 $0$ & $+0$  \\
 $1$ & $+1$ \\
 \ldots & \ldots \\
 $49$ & $+49$ \\
 $50$ & $-50$ \\
 \ldots & \ldots \\
 $99$ & $-1$
\end{tabular}
\end{center}

\item Sei $b=2$, $n=3$ Der darstellbare Bereich ist $-4 \le  z \le 3$. \\
\begin{center}
\begin{tabular}{ c c }
 Bitmuster & Dezimaldarstellung  \\ 
 $000$ & $0$   \\  
 $001$ & $1$  \\
 \ldots & \ldots \\
 $100$ & $-4$ \\
 \ldots & \ldots \\
 $111$ & $-1$
\end{tabular}
\end{center}
\end{itemize}
\end{example}%
Wir betrachten nun Addition und Subtraktion zweier Zahlen in b-Komplement-Darstellung. 
Hierzu bezeichne $(x)_{K_b} \oplus (y)_{K_b}$ die ziffernweise Addition der Darstellungen von x und y mit Übertrag ("schriftlich rechnen"), 
wobei ein eventueller Überlauf auf die $(n+1)$-te Stelle vernachlässigt wird (wir rechen also immer mit modulo $b^{n}$.
\begin{theorem}[Addition in b-Komplement-Darstelllung]
	Seien x und y zwei n-stellige, b-adische Zahlen und x,y und $x+y$ im darstellbaren Bereich.
Dann gilt:
\[
(x+y)_{K_b} = (x)_{K_b} \oplus (y)_{K_b}
\]
\end{theorem}
\begin{proof}
Wir betrachten dazu mehrere Fälle.
\begin{itemize}
	\item Fall $x,y \ge 0$: \\
\begin{align*}
(x)_{K_b} \oplus (y)_{K_b}
    &\overset{\text{Def.}}{=}\left( (x)_b + (y)_b \right) \mod b^{n} \\
    &\overset{\text{Def.}}{=} (x+y) \mod b^{n} \\
    &\overset{\text{Def.}}{=} (x+y)_{K_b} \\
\end{align*}
Der letzte Schritt ist möglich, da $(x+y)_{K_b}$ im darstellbaren Bereich sind.
\item Fall $x,y <0$
\begin{align*}
(x)_{K_b} \oplus (y)_{K_b}
&\overset{Def.}{=} \left( \left( K_b(|x|) \right)_b + \left( K_b(|y|) \right)_b \right) \mod b^{n} \\
&\overset{   }{=}\left( (K_b(|x|)) +\left( K_b\left( |x| \right) \right)\right) \mod b^{n} \\
&= (b^{n}-|x| + b^{n}-|y|) \mod b^{n} \\
&= (x+y) \mod b^{n} \\
&= (x+y)_{K_b}
\end{align*}
\item Fall $x\ge 0, y<0$: \\
\begin{align*}
(x)_{K_b} \oplus (y)_{K_b}
&\overset{Def.}{=} ((x)_b + (K_b(|y|))_b) \mod b^{n} \\
&=(x+K_b(|y|)) \mod b^{n} \\
&=(x+b^{n}-|y|) \mod b^{n} \\
&=(x+y) \mod b^{n} \\
&= (x+y)_{K_b}
\end{align*}
\item Fall $x<0, y\ge 0$: Analog
\end{itemize}
\end{proof}
\begin{theorem}[Subtraktion in b-Komplement-Darstellung]
	Seien x und y n-stellige b-adische Zahlen und x,y und x-y im darstellbaren Bereich.
	Dann gilt:
	\[
	(x-y)_{K_b} = (x)_{K_b} \oplus \left( K_b(y) \right)_{K_b}
	\]
\end{theorem}
\begin{proof}
\begin{itemize}
	\item Fall $y=0$ nichts zu zeigen.
	\item $y \neq 0$: \eqref{eqn:komplement} impliziert:
		\[
		-y=K_b(y) -b^{n}
		\]
	mit modulo $b^{n}$-rechnen folgt, dass
	\[
		(-y)_{K_b}= (K_b(y))_{K_b}
	\]
	ist und somit:
	\begin{align*}
		(x-y)_{K_b}
		&= (x+(-y))_{K_b} \\
		&= (x)_{K_b} \oplus (-y)_{K_b} \\
		&= (x)_{K_b} \oplus (K_b(y))_{K_b}	
	\end{align*}
\end{itemize}
\end{proof}
\begin{example}
Für $b=10$ und $n=2$ ist der darstellbare Bereich $-50 \le  z \le 49$
\begin{itemize}
	\item $(20+7)_{K_{10}} = (20)_{K_{10}} \oplus (7)_{K_{10}} =(27)_{K_{10}}=27$
	\item $28-5 = 28+ (-5)= (28)_{K_{10}} \oplus (95)_{K_{10}} = (23)_{K_{10}} =23 $
	\item $-18-20= (-18)+(-20) = \ldots = -28$
\end{itemize}
\end{example}
Die darstellbaren Zahlen kann man sich beim $K_b$-Komplement als Zahlenrad vorstellen.

%Hier muss eine coole Uhr eingefügt werden.

\paragraph{Achtung} Ein eventueller Überlauf bzw. Unterlauf wird im Allgemeinen nicht aufgefangen.
\begin{example}
In n-stelliger Binärarithmetik ist die größte darstellbare Zahl $x_{max} = (011\ldots 1)_{K_2}$ gleich  $2^{n-1}-1$. Hingegen ist $x_{max}+1=(100\ldots 0)_{K_2}$ und wir als $-2^{n-1}$ interpretiert.
\end{example}
\subsection{Fest-Komma-Darstellung}
\begin{definition}
	Bei der Festkommadarstellung einer n-stelligen Zahl werden k Vorkomma und n-k Nachkommastellen definiert:
	\[
	z=+-(z_{k-1} \ldots z_0.z_{-1} \ldots z_{k-n})_b = +- \sum_{i=k-n}^{k-1}z_i b^{i}
	\]

\end{definition}
\begin{example}
Im Zehner System wie gehabt.\\
Im Binärsystem ergibt sich folgendes: $(101.01)_2= 2^{2}+ 2^{0}+ 2^{-2}=5.25$
\end{example}
\paragraph{Achtung} Im Gegensatz zur Darstellung ganzer Zahlen können bereits bei der Konvertierung von Dezimalzahlen in das b-adische Zahlensystem Rundungsfehler auftreten.
\begin{example}
	$(0.8)_{10}=(0.110\overline{1100})_2$
\end{example}
Das größte Problem der Festkommadarstellung ist alllerdings, dass der darstellbare Bereich stark eingeschränkt ist und schlecht aufgelöst ist, da der Abstand zwischen zweier Zahlen immer gleich ist.
\begin{example}
Die kleinste darstellbare Zahl in Fixkommadarstellung ist \[
z_1=(0 \ldots 0.0 \ldots 0 1)_b
\]
Die zweitkleinste Zahl ist $z_2=2z_1$. Wir wollen $x=\frac{z_1+z_2}{2}$ in Fixkommadarstellung darstellen, müssen wir entweder zu $z_1$ abrunden oder zu $z_2$ aufrunden.
\end{example}
\begin{fluff}
Der relative Fehler dieses Runden ist:
\[
\frac{|x-z_1|}{|x|}=\frac{1}{3}
\]
Analog für $z_2$. \\
Solche Fehler machen jede Rechnung unbrauchbar.
\end{fluff}
\subsection{Gleitkommadarstellung}
\begin{definition}[Gleitkommadarstellung]
	Die Gleitkommastellung einer Zahl $z \in  \R$ ist gegeben durch:
	\[
	z=+-m\cdot b^{e}
	\]
mit einer \underline{Matisse} m, dem \underline{Exponenten} e und der \underline{Basis} b.
\end{definition}
Der Einfachheit halber nehmen wir an, dass die Basis für alle Zahlen gleich ist, obwohl sie prinzipiell verschieden sein könnte.
\begin{example}
Die Gleitkommadarstellungen von:
\begin{itemize}
	\item $(-384.753)_{10}= -3.84753 \cdot 10^2$
	\item $(0.00042)_{10}=4.2 \cdot 10^{-4d}$
	\item $(1010.101)_2= (1.010101)_2 \cdot 2^{3}$
\end{itemize}
\end{example}
\paragraph{Achtung:} Die Gleitkommadarstellung ist \underline{nicht} eindeutig!

\begin{definition}
Die Matisse m heißt \underline{normalisiert}, falls $m=m_1.m_2m_3 \ldots m_t$ mit $1\le m_1 \le b$.
\end{definition}
Um die eindeutige, normalisierte Gleitkommadarstellung im Computer zu speichern, müssen wir festlegen, wie viele Stellen für Matisse und Exponent zur Verfügung gestellt werden. Dies resultiert in der Menge 
\[
F=F(b,t,e_{min}, e_{max}) = \{z= +-m_1.m_2m_3\ldots m_t \cdot b^{e} | e_{min} \le e \le e_{max} \} 
\]
Da 0 nicht in dieser Form dargestellt werden kann, reserviert man dafür eine spezielle Ziffernfolge in Matisse und Exponent.
%Hier fehlt wieder ein schöne Grafik
\begin{remark}
Das Hidden Bit ist hilfreich
\begin{itemize}
	\item Für $b=2$ kann die erste Ziffer $m_1$ der Matisse weggelassen werden (Hidden Bit)
	\item Um den Exponenten besser vergleichen zu können, verwendet man oft die Exzess- oder Bias-Darstellung. Durch Addition der Exzesser $|e_{min}|+1$ wird der Exponetn auf den Bereich $1,2,\ldots, |e_{min}|+e_{max} +1 $ transformiert.
\end{itemize}
\end{remark}
\begin{example}[IEEE 754 Standard]
	Betrachte binäre Gleitkommazhalen mit 64 Bit auf dem Computer. 
	\begin{itemize}
		\item 52 Bit für die Matisse in Hidden Bit Darstellung
		\item 11 Bit für den Exponenten mit $e_{min} = -1022$ und $e_{max} =1023$ gespeichert in Exzessdarstellung.
		\item 1 Bit als Vorzeichen.
	\end{itemize}
Weiter Fälle können Online nachgelesen werden.
\end{example}

\subsubsection{Genauigkeit der Gleitkommadarstellung}
Da die Menge aller Zahlen in $F=F(b,t,e_{min},e_{max})$ endlich ist, müssen wir Zahlen in $\R \setminus  F$ geeignet annähern.

\begin{definition}
Die Rundung ist eine Abbildung $rd\colon \R \to F $ mit 
\begin{itemize}
	\item $rd(a)=a$, $a \in F$
	\item $rd(z)$, $z \in  \R$ ist gegeben so, dass $|z-rd(z)|=\underset{a \in F}{\min}(z-a)$ für alle $z \in  \R$.
\end{itemize}
\end{definition}
\begin{definition}[Maschinengenauigkeit]
Den maximalen relativen Rundungsfehler $\varepsilon_{mach}$ für $z_{min} \le |z| \le z_{max}$ nennt man Maschinengenauigkeit.
Die Stellen der Mantisse heißen \underline{signfikante Stellen}.
Wenn die Mantisse t-stellig ist, spricht man von \underline{t-stelliger Arithmetik}.
\end{definition}
\begin{theorem}[Maschinengenauigkeit von F]
	Die Maschinengenauigkeit $\varepsilon_{mach}$ für $F=F(b,t,e_{min},e_{max})$ ist:
	\[
	\varepsilon_{mach} = \frac{1}{2} b^{1-t} \text{.}
	\]
\end{theorem}
\begin{proof}
Betrachte relativen Rundungsfehler $\varepsilon$, der vom Abscheiden nicht signifikanten Stellen herrüht. Sei $z_{min} < x < z_{max}$ und $\tilde{x}$ die durch Abschneiden entstehende Zahl.
Dann gilt:
\begin{align*}
	\varepsilon
	&= \frac{|x-\tilde{x}|}{|x|} \\
	&= \frac{|x_1.x_2x_3 \ldots x_t x_{t+1}\ldots \cdot b^{e}-x_1x_2x_3\ldots x_t \cdot b^{e}}{|x|} \\
	&=\frac{|0.x_{t+1}\ldots| \cdot |b^{e+1-t}|}{|x|}
\end{align*}
Da $|0.x_{t+1}\ldots|<1$ und $b^{e}\le |x|$ gilt:
\[
\varepsilon <\frac{b^{e+1-t}}{b^{e}}=b^{1-t}
\]
Da der Rundungsfehler $\varepsilon_{mach}$ höchsten halb so groß ist wie der Abschneidefehler folgt die Behauptung.
\end{proof}
Die Maschinengenauigkeit $\varepsilon_{mach}$ ist die wichtigste Größe zur Beurteilung der Genauigkeit von Gleitkommarechnungen am Computer. Sie gibt Aufschluss zur Anzahl signifikanter Stellen zur Basis $b$.
Die zugehörige Anzahl $s$ Stellen im Dezimalsystem erhält man durch das Auflösen von:
\[
\varepsilon_{mach} = \frac{1}{2}b^{1-t}=\frac{1}{2}10^{1-s}
\]
nach s. Es folgt daher:
\[
s= \lfloor 1+(t-1)\log_{10}(b) \rfloor
\]
Für den IEEE 754 Standard mit $b=2, t=53$ erhält man $s=16$ signifikante Stellen.
